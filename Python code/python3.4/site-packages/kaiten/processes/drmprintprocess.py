import ctypes
import os
import random
import kaiten.constants
import kaiten.error
import kaiten.drm
import kaiten.thingiverse

from kaiten.processes.printprocess import PrintProcess

class DRMPrintProcess(PrintProcess):
    def __init__(self, *args, layout_id, **kwargs):
        super(DRMPrintProcess, self).__init__(*args, **kwargs)
        if self._config["kaiten"]["drm_server"]\
           != kaiten.constants.drm_server_url_default:
            self._log.info("Using nonstandard DRM server {0}"\
                           .format(self._config["kaiten"]["drm_server"]))

        self._log.info("DRM print ")
        self._mb_token = None
        if self._client.account:
            tokens = self._client.account.makerbot_tokens
            if tokens:
                self._mb_token = random.choice(tokens)
        self._drm_store = kaiten.drm.DRMStoreV2(
            self._machine_manager._server,
            self._config["kaiten"]["drm_server"],
            self._mb_token,
            layout_id,
            kaiten.constants.tmp_drm_file)
        # Make this look like a normal print
        self._name = "PrintProcess"
        self._layout_id = layout_id
        self._print_credits = None
        self._got_drm_completion_response = False

    def _set_filepath(self):
        """
        Override implementation
        This function:
        1. Gets the layout information so we know the name of the print
        2. Tells the user to clear build plate
        3. Downloads the metadata (a .makerbot file without a toolpath)
        4. Streams the toolpath
        Note that we do not set the print_again flag to true, unlike the
        parent class implementation
        """
        self._machine_manager._server.analytics_event("drm_print_started",
            label=self._method)
        if self._mb_token is None:
            self._log.error("DRM Print: No token set")
            # TODO: Get copy for a more specific error here
            yield kaiten.error.printing_network_error
        try:
            self._log.info("DRM Print: Starting layout lookup...")
            layout = kaiten.thingiverse.Layout(
                self._mb_token,
                self._machine_manager._server,
                self._config)
            layout.load_from_id(self._layout_id, {'print_credits': True})
            layout.check_error_response()
            while layout.id() is None:
                layout.check_error_response()
                yield
            # Printerpanel uses the filename for displaying the filename
            filename = "{0}.makerbot".format(layout.get("name"))
            self.filename = layout.get("name")
            current_print_dir = kaiten.constants.current_print_dir
            metadata_path = os.path.join(current_print_dir, filename)
            self._print_credits = layout.get('print_credits')
            self._log.info("DRM Print: Starting metadata download for {0}..." \
                .format(filename))
            self._drm_store.get_metadata(metadata_path)
            # Ask user to clear buildplate while metadata downloads
            self.filepath = metadata_path
            while not self._drm_store.metadata_downloaded():
                yield
            yield from self._do_clear_build_plate()
            self._log.info("DRM Print: Metadata finished. Starting toolpath stream")
            self._drm_store.start()
        except kaiten.error.ThingiverseException:
            yield kaiten.error.printing_network_error

    def _initialize_parser(self):
        """
        The parser reads out of the drm store for drm prints, and
        cannot be initialized until the store is completed
        """
        self._log.info("DRM Print: Waiting on stream to complete")
        try:
            while not self._drm_store.completed():
                yield
        except kaiten.error.ThingiverseException:
            yield kaiten.error.printing_network_error
        self._machine_manager._server.notify_client('lcd', 'print_file_valid',
                                                    {'filepath': self.filepath})
        self._log.info("DRM Print: Stream completed. Initializing parser.")
        yield from self._initialize_file()
        self._machine_parser_interface = self._pymach.create_parser_interface()
        c_path = ctypes.c_char_p(bytes(self._drm_store.path, "UTF-8"))
        c_fd = ctypes.c_int(self._drm_store.fileno())
        c_axes = ctypes.c_size_t(3 + self._machine_manager.extruder_count())
        self._jtparser\
            = self._print_module.CreateJTParser(self._machine_parser_interface,
                                                c_path, c_axes, c_fd)
        yield

    def get_info_dict(self):
        """
        Override implementation
        Provide 'print_credits' metadata if this can only be printed a
        limited number of times.
        """
        info = super(DRMPrintProcess, self).get_info_dict()
        if self._print_credits is not None:
            info['print_credits'] = self._print_credits
        return info

    def _drm_completion_callback(self, data):
        """
        Update 'print_credits' using the response from the /completion endpoint.
        """
        self._got_drm_completion_response = True
        credits = data.get('print_credits')
        if credits is not None:
            self._print_credits = credits
            self._log.info("DRM Print: {} prints remaining.".format(credits))
        elif self._print_credits is not None:
            self._log.warning("DRM Print: unable to parse 'print_credits' from "
                "completion response for limited print.")

    def _wait_for_drm_completion_response(self):
        """
        Yield until we either:
        1. Get a successful response from request to the /completion endpoint OR
        2. The drm_store indicates an error occurred.
        """
        try:
            while not self._got_drm_completion_response:
                self._drm_store.check_error()
                yield
        except kaiten.error.ThingiverseException:
            self._log.warning("DRM Print: Failed to get completion response.")

    def _do_cleanup(self):
        # Clear deferred drm_store errors to avoid false positives on error
        # handling for drm_store.send_completion().
        self._drm_store.clear_error()
        self._drm_store.send_completion(self.cancelled, self.failed,
            self._drm_completion_callback)
        self._drm_store.close()
        yield from super(DRMPrintProcess, self)._do_cleanup()
        yield from self._wait_for_drm_completion_response()
