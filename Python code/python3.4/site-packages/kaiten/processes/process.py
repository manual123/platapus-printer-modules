"""A generic process.

Used as a superclass for all other processes.
"""
import datetime
import json
import logging
import uuid

import kaiten.decorator
import kaiten.enum
import kaiten.error

import kaiten.activities.activitybase

# Process inherits from ActivityBase to share low level machine procedures
class Process(kaiten.activities.activitybase.ActivityBase):

    def __init__(self, machine_manager, pymach, config, name=None, steps=[]):
        """
        Superclass Implementation
        """
        super().__init__(machine_manager, pymach, config)
        self.id = machine_manager._get_process_id()
        # Only print processes have a username, but the code
        # that reports it back lives here...
        self.username = None
        self._name = name
        self.start_time = datetime.datetime.utcnow()
        self.elapsed_time = 0
        # Unique per process
        self._process_id = str(uuid.uuid4())
        self.last_watchdog_update = self.start_time
        self.steps = kaiten.enum.enum("process_steps",
            "running",
            "cancelling",
            "cleaning_up",
            "done"
        )
        self.steps.extend(*steps)
        self._step_reasons = kaiten.enum.enum("step_reasons",
            "error"
        )
        self._cancellable = True
        self.ignore_criticals = False
        self.complete = False
        self.cancelled = False
        self.failed = False # Did not complete due to an error
        # The generic step.  All processes are "running" unless their
        # specific implementation decides otherwise. We do not notify the client
        # of this initial step change
        self.step = self.steps.running
        # reason and corresponding error for step changes
        self._error = None
        self._reason = None

        # These are toolhead erorrs we want to allow
        self._ignorable_toolhead_errors = set()
        self._cancellable_toolhead_errors = (set(kaiten.error.toolhead_errors)
                                             - self.ignorable_toolhead_errors)
        # Stop flag
        self._stop = False
        # Override to be cancelled by anything that runs (as preheat process should)
        self.anything_preempts = False
        self._environment = {
            "Z_HEIGHT": self._config["axis_length"]["z"],
            "X_HOME": self._config["home"]["position_mm"]["x"],
            "Y_HOME": self._config["home"]["position_mm"]["y"],
            "Z_HOME": self._config["home"]["position_mm"]["z"],
            "X_PARK" : self._config.get("safe_park", self._config["park"])["x"],
            "Y_PARK" : self._config.get("safe_park", self._config["park"])["y"],
            "Z_PARK" : self._config.get("safe_park", self._config["park"])["z"],
            "X_PARK_PREP" : self._config["park_prep"]["x"],
            "Y_PARK_PREP" : self._config["park_prep"]["y"],
            "X_PURGE_START": self._config["purge_start_position"]["x"],
            "Y_PURGE_START": self._config["purge_start_position"]["y"],
            "Z_PURGE_START": self._config["purge_start_position"]["z"],
            "A_PURGE_START": self._config["purge_start_position"]["a"],
            "X_PURGE_END": self._config["start_position"]["x"],
            "Y_PURGE_END": self._config["start_position"]["y"],
            "Z_PURGE_END": self._config["start_position"]["z"],
            "A_PURGE_END": self._config["start_position"]["a"],
            "HOME_TEMP" : self._config["home"]["temperature"],
            "X_SAFE_ZHOME" : self._config["home"].get("safe_z_home_position",
                                                      {"x": 0})["x"],
            "Y_SAFE_ZHOME" : self._config["home"].get("safe_z_home_position",
                                                      {"y": 0})["y"]
        }
        thconf = self._config["toolheads"]
        for key, th in thconf.items():
            for loc in th["locations"]:
                if 'extruder' in th['type']:
                    self._environment['EXTRUDER_{}_PREHEAT_TEMP'.format(loc)]\
                        = th['heater']['preheat_temperature']
                elif 'chamber' in th['type']:
                    self._environment['CHAMBER_PREHEAT_TEMP']\
                        = th['heater']['preheat_temperature']
                else:
                    self._log.warning("Toolhead {} has no useful type"
                                      .format(key))
        self._current_activity = None
        self._process_methods = self._get_process_methods()
        self.tasklets = self._get_tasklets()
        self._set_requires_heating(False)

    def _ensure_tool_attached(self, tool_idx=None):
        if not self._config['kaiten']['do_seat_tool']:
            return
        if tool_idx is None:
            tool_idx = self._config['active_tool']
        yield from self._ensure_move_axis(3+tool_idx, 20, 10, True)
        if not self._pymach.is_tool_connected(tool_idx):
            yield kaiten.error.no_tool_connected
        else:
            yield kaiten.error.ok

    # This structure is needed to make properties actually inheritable. Using
    # the @property decorator or passing the getter/setter methods into
    # property() results in a static setup that can't be overridden without
    # lots of hackiness. This little bit of hackiness lets any subclass that
    # wants to override _{get,set}_{ignorable,cancellable}_toolhead_errors to
    # override the property.
    def _get_ignorable_toolhead_errors(self):
        return self._ignorable_toolhead_errors

    def _set_ignorable_toolhead_errors(self, iterable):
        self._ignorable_toolhead_errors = set(iterable)

    ignorable_toolhead_errors = property(fget=lambda self:\
                                         self._get_ignorable_toolhead_errors(),
                                         fset=lambda self, iterable:\
                                         self._set_ignorable_toolhead_errors(iterable))

    def _get_cancellable_toolhead_errors(self):
        return self._cancellable_toolhead_errors

    def _set_cancellable_toolhead_errors(self, iterable):
        self._cancellable_toolhead_errors = set(iterable)

    cancellable_toolhead_errors = property(fget=lambda self:\
                                           self._get_cancellable_toolhead_errors(),
                                           fset=lambda self, iterable:\
                                           self._set_cancellable_toolhead_errors(iterable))

    def ignore_all_toolhead_errors(self):
        self.ignorable_toolhead_errors = kaiten.error.toolhead_errors

    def _set_requires_heating(self, requires_heating:bool):
        """ Superclass implementation

        Handle all required state for letting the machine heat up to print.
        """
        if requires_heating:
            self.ignorable_toolhead_errors\
                .discard(kaiten.error.heater_hold_watchdog_triggered)
            self.cancellable_toolhead_errors\
                .update({kaiten.error.heater_hold_watchdog_triggered})
            self.overrides_heater_watchdog = True
        else:
            self.ignorable_toolhead_errors\
                .update({kaiten.error.heater_hold_watchdog_triggered})
            self.cancellable_toolhead_errors\
                .discard(kaiten.error.heater_hold_watchdog_triggered)
            self.overrides_heater_watchdog = False

    def _get_process_methods(self):
        """
        Gets all the callable process methods, organized as a dict of
        { step : { method_name : callback, ... }, ... }

        These methods should not be generators and should return quickly.

        Most often, they manipulate self.tasklets, although we may want to
        set up a better architecture for this if more processes use them.

        Following jsonrpc's lead, we have intentionally avoided inspect
        here for performance reasons.
        """
        ret = {}
        for attribute_name in dir(self):
            attr = getattr(self, attribute_name)
            # If it quacks like a function...
            if hasattr(attr, '__call__') and \
                getattr(attr, kaiten.decorator.FunctionAttributes.process_method, False):
                available_steps = getattr(attr,
                    kaiten.decorator.FunctionAttributes.available_during, [])
                if not hasattr(available_steps, '__iter__'):
                    # When using unittest.Mock, we get a non-iterable returned
                    # TODO: find a good test for skipping Mock attributes above
                    continue
                for step in available_steps:
                    if step not in ret:
                        ret[step] = {}
                    ret[step][attribute_name] = attr
        return ret

    def _create_event_log_message(self, msg, event_type, error_dict=None):
        """
        Process Implementation
        """
        return super()._create_event_log_message(msg, event_type, error_dict)


    def _callable_methods(self):
        """
        Returns a dict of function_name : function_object
        available during the current step
        """
        if self.step in self._process_methods:
            return self._process_methods[self.step]
        else:
            return {}

    def stop(self):
        self._stop = True

    def get_type(self):
        """
        Superclass Implementation

        Used to determine what type of object this is
        """
        return "process"

    def get_id(self):
        return self._process_id

    def get_name(self):
        """
        Returns the name of this process
        """
        if not self._name:
            return self.__class__.__name__
        else:
            return self._name

    def _get_tasklets(self):
        """
        Superclass Implementation
        """
        yield from self.initialize()
        yield from self.run()
        yield from self.end()
        yield from self.cleanup()

    def _client_request(self, client, method, params):
        """
        Generator for sending a generic request to a specific client

        @param client: One of "lcd" or "fcgi"
        """
        request_done = {}
        def callback(result):
            if "result" in result:
                request_done["result"] = result["result"]
            elif 'error' in result:
                self._log.info("JsonRPC error for %s(%r):\n%r",
                               method, params, result['error'])
                request_done["error"] = result['error']
            else:
                self._log.info("Invalid JsonRPC response for %s(%r)",
                               method, params)
                request_done["error"] = None
        self._machine_manager._server.make_client_request(client, method, params, callback)
        while not request_done:
            yield
        if 'error' in request_done:
            raise kaiten.error.UserRequestException(request_done['error'])
        return request_done["result"]

    def _lcd_request_user_input(self, context):
        """
        Superclass Implementation
        Sends a jsonrpc request to the LCD to ask the user to either continue
        or stop
        """
        method = "request_user_input"
        params = {"context": context}
        result = yield from self._client_request('lcd', method, params)
        # I am not sure if this is being used anymore...
        if not result:
            raise kaiten.error.UserRequestException(result)
        return result

    def _call_pymach(self, func_name, *args, **kwargs):
        """
        Superclass Implementation
        Abstraction for calling pymaching functions by string name.
        """
        result = yield from getattr(self._pymach, func_name)(*args, **kwargs)
        return result

    def initialize(self):
        """
        Superclass Implementation
        """
        self.cancelled = False
        yield from self._do_initialize()

    def run(self):
        """
        Superclass Implementation
        """
        self._log.debug("process running")
        yield from self._do_run()
        self.complete = True
        self._log.debug("process finished Running")

    def end(self):
        """
        Superclass Implementation
        """
        self._log.debug("process ending")
        yield from self._do_end()
        self._log.debug("process finished Ending")

    def cleanup(self):
        """
        Superclass Implementation
        """
        self._log.debug("process Cleaning Up")
        self._cancellable = False
        self._step_change(self.steps.cleaning_up)
        if self._current_activity:
            yield from self._current_activity.cleanup_generator
        yield from self._do_cleanup()
        self._step_change(self.steps.done)
        self._log.debug("process Finished Cleaning Up")

    def handle_error(self, error_dict):
        """
        Superclass Implementation

        return True if triggering a step change to stop
        an error notification from being sent
        """
        return False

    def handle_acknowledge(self):
        # called when a user acknlowdeges an error
        # returns whether process overrides default behavior
        return False

    def is_cancellable(self):
        """ Superclass Implementation """
        return self._cancellable

    def cancel(self, error_dict=None):
        """
        Superclass Implementation
        Cancels the current process.  If this process is suspended, we will
        deleagte to _cancel_from_suspend, which will unsuspend then cancel
        """
        # We explicitely unset pause here to support cancelling a paused print
        self.cancelled = True
        if error_dict:
            self.failed = True
        self._cancellable = False
        self._step_change(self.steps.cancelling, error_dict)
        # TODO: we should really be closing tasklets everytime it is reassigned
        self.tasklets.close()
        self.tasklets = self._cancel(error_dict)

    def _send_state_notification(self):
        # Sends a state notification
        # Does not need to explicitly be called if there is a step change
        self._machine_manager.state_notification()

    def _cancel(self, error_dict=None):
        """
        Superclass Implementation
        """
        with self._machine_manager.light_context("idle"):
            if self._current_activity:
                yield from self._current_activity.cancel(error_dict)
            yield from self._do_cancel(error_dict)
            yield from self.cleanup()

    def _do_initialize(self):
        """
        Superclass Implementation
        """
        yield kaiten.error.ok

    def _do_run(self):
        """
        Superclass Implementation
        """
        yield kaiten.error.ok

    def _do_end(self):
        """
        Superclass Implementation
        """
        yield kaiten.error.ok

    def _do_cleanup(self):
        """
        Superclass Implementation
        """
        yield kaiten.error.ok

    def _do_cancel(self, error_dict=None):
        """
        Superclass Implementation
        """
        yield kaiten.error.ok

    def _step_change(self, new_step, error_dict=None):
        """
        Superclass Implementation
        """
        if self.step != new_step:
            if error_dict is not None:
                self._error = error_dict
                self._reason = self._step_reasons.error
            self.step = new_step
            self._send_state_notification()

    def _clear_reason_and_error(self):
        """
        Errors that cause step changes are cleared when a process_method
        is called.
        """
        self._reason = None
        self._error = None

    def process_method(self, method, params):
        """
        Call a process method on this process, if it is available.
        This is called from machine_manager's jsonrpc method process_method.
        Calling one of these will clear the reason and error fields of the process.
        """
        callable_methods = self._callable_methods()
        if method in callable_methods:
            self._log.info("Process method invoked: {0}".format(method))
            self._clear_reason_and_error()
            callable_methods[method](**params)
        else:
            self._log.info("Process method {0} cannot be called in step {1}"\
                           .format(method, self.step))
            raise kaiten.error.ProcessMethodNotCallableException

    def force_cancel(self):
        """
        Superclass implementation

        Send a done notification so connected clients know a process is going
        away.
        """
        self._step_change(self.steps.done)

    def callable_method_names(self):
        return list(self._callable_methods().keys())

    def get_info_dict(self):
        """
        Superclass Implementation
        """
        info = {
            'id': self.id,
            'name': self.get_name(),
            'username': self.username,
            'step': self.step,
            'reason': self._reason,
            'error': self._error,
            'cancellable': self.is_cancellable(),
            'cancelled': self.cancelled,
            'complete': self.complete,
            'methods': self.callable_method_names()
        }
        return info

    def __str__(self):
        """
        Superclass Implementation
        """
        return json.dumps(self.get_info_dict())

    def __repr__(self):
        """
        Superclass Implementation
        """
        return "%r" % (self.get_info_dict())

    def contract_duration(self):
        """
        Superclass Implementation
        """
        return datetime.timedelta(0, 0, 0, 50)

    def expected_run_time(self):
        return datetime.timedelta(seconds=kaiten.constants.normal_generator_time)

    def _create_and_run_activity(self, activity_class, *args, **kwargs):
        activity = self._create_activity(activity_class, *args, **kwargs)
        yield from self._run_activity(activity)

    def _create_activity(self, activity_class, *args, **kwargs):
        # automatically pass in machine_manager, pymach, and config
        return activity_class(
            self._machine_manager,
            self._pymach,
            self._config,
            *args,
            **kwargs)

    def _run_activity(self, activity):
        self._current_activity = activity
        yield from activity.run()
        yield from activity.cleanup_generator
        self._current_activity = None

    def get_tool_usage_stats(self):
        """ Process superclass implementation
        Override in your derived class (probably just PrintProcess) to actually
        give useful information to the analytics manager
        """
        raise NotImplementedError

