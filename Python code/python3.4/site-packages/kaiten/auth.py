import collections
import json
import os
import random
import string

import kaiten.constants
import kaiten.decorator
from kaiten.jsonrpc import JsonRpcException
import kaiten.log
import kaiten.shelve

class InvalidAccountError(Exception):
    pass

class Account():
    """
    Representation of an "account"

    Every different account must have a different username.  Generally
    every account is just a makerbot account, with a makerbot username
    and a makerbot token.  But some clients support connecting without
    a makerbot account, and connect with just an arbitrary username, an
    arbitrary client secret, and a code that we supply.  These clients
    may end up grouped together under a single account, possibly an
    actual makerbot account, all depending on whether the usernames
    happen to match.

    Usernames are case insensitive.  What this means for account objects
    is that the account username is not always equal to the username
    used to create the account object.  Specifically, if a different
    case variant of the same username is already present in our database
    then that variant will be the account username.

    Note that this object is a view of the account info and not a copy.
    Care should be taken to avoid locally caching any data from the
    account object for an extended length of time.
    """
    # We store the database of accounts in the class itself along with
    # some data structures to make some db operations faster.  These
    # all get initialized by set_db(), so nothing will work before
    # this is called.
    _db = None
    _username_case_map = None

    # We don't want to attach any data to an account that is not
    # persistent in our database, so we never want to assign an
    # arbitrary attribute to an account.  Instead we want to add
    # a new element to _db[_username] and properties/methods to
    # access the data.  We use __slots__ to enforce this.
    __slots__ = ('_username',)

    @classmethod
    def set_db(cls, db):
        cls._db = db
        cls._username_case_map = case_map = {}
        cased_usernames = list(db)
        for cased_username in cased_usernames:
            lower_username = cased_username.lower()
            if lower_username in case_map:
                # We have two separate accounts for the same username,
                # so we need to merge them into one account
                std_cased_username = case_map[lower_username]
                old_data = (db[cased_username], db[std_cased_username])
                data = [l0 + l1 for l0, l1 in zip(*old_data)]
                # Filter out duplicate account tokens
                data[0] = list(set(data[0]))
                db[std_cased_username] = data
                del db[cased_username]
            else:
                case_map[lower_username] = cased_username

    @classmethod
    def check_username(cls, username):
        """
        Returns the canonically cased version of a username for a known
        account, or None if the username does not match a known account.
        """
        return cls._username_case_map.get(username.lower())

    @classmethod
    def all_accounts(cls):
        """
        Return an iterator through all accounts

        Iterator behavior is undefined if accounts are added or deleted
        while it is in use.
        """
        return (cls(username) for username in cls._db)

    @classmethod
    def drop_username(cls, username):
        """
        Delete an account.

        All existing account objects for this account will be invalid
        after invoking this.
        """
        std_username = cls._username_case_map.pop(username.lower())
        del cls._db[std_username]

    @classmethod
    def drop_all(cls):
        """
        Delete all accounts.

        All existing account objects will be invalid after invoking this.
        """
        cls._db.clear()
        cls._username_case_map.clear()

    def __init__(self, username):
        username = self._username_case_map.setdefault(username.lower(), username)
        self._username = username
        self._db.setdefault(username, [[], []])

    @property
    def valid(self):
        """ False if this account has been deleted """
        return self._username in self._db

    def _check_valid(self):
        if not self.valid:
            raise InvalidAccountError('Invalid account "%s"' % self._username)

    @property
    def username(self):
        """ The unique username for this account (read only) """
        return self._username

    @property
    def makerbot_tokens(self):
        """ A list of valid makerbot_tokens for this account """
        self._check_valid()
        return self._db[self._username][0]

    @makerbot_tokens.setter
    def makerbot_tokens(self, token):
        if type(token) is not str:
            return
        self._check_valid()
        data = self._db[self._username]
        # Avoid duplication here instead of in every single call spot
        if token not in data[0]:
            data[0].append(token)
        self._db[self._username] = data

    def check_local_auth(self, local_secret, local_code):
        self._check_valid()
        local_auth = self._db[self._username][1]
        return [local_secret, local_code] in local_auth

    def add_local_auth(self, local_secret, local_code):
        self._check_valid()
        data = self._db[self._username]
        data[1].append([local_secret, local_code])
        self._db[self._username] = data

    def local_auth_count(self):
        self._check_valid()
        return len(self._db[self._username][1])

class TokenDict(collections.OrderedDict):
    """
    Dict with a maximum number of elements.

    Least recently inserted keys are silently dropped to keep
    the total number of elements below a fixed size.  We use
    this for one_time_tokens because we don't require or even
    strongly encourage clients to actually use every single
    token they are issued.
    """
    def __init__(self, *args, max_elems=32, **kwargs):
        super().__init__(*args, **kwargs)
        self._max_elems = max_elems

    def __setitem__(self, key, value):
        while len(self) >= self._max_elems:
            self.popitem(last=False)
        super().__setitem__(key, value)

class AuthStore():
    """
    Manage all authentication tokens and methods
    """
    def __init__(self, server):
        self._log = kaiten.log.getlogger(self)
        self._server = server
        self._account_map = TokenDict()
        self._sysrand = random.SystemRandom()
        self._tethering_since = None

        db_path = kaiten.constants.auth_store_db_path
        os.makedirs(os.path.dirname(db_path), exist_ok=True)
        Account.set_db(kaiten.shelve.JsonShelf(db_path))

    @kaiten.decorator.jsonrpc
    @kaiten.decorator.lower_priv
    @kaiten.decorator.require_secure
    @kaiten.decorator.pass_client
    @kaiten.decorator.pass_callback
    def authorize(self, username:str, makerbot_token:str=None,
                  local_secret:str=None, chamber_blink:bool=False,
                  client=None, callback=None) -> dict:
        """
        Authorize an account for the first time.

        This will always ask for verification via the bot ui to
        authorize the given user, and cannot succesfully complete
        without someone physically present to press a button.

        For all clients with a connected makerbot account, just the
        account username and the account token should be used.  Other
        clients should provide a descriptive, non generic username
        and a randomly generated local_secret, and must also store
        the returned local_code in order to reauthorize.

        If accepted this will both authenticate the current client and
        return a single use token that can be used to authenticate a
        single additional client.

        @param username: Makerbot account name, or other display name
        @param makerbot_token: Makerbot account token
        @param local_secret: Random string for accountless auth
        @param chamber_blink: Blink chamber instead of knob to auth
        @return dict:  Dict containing:
             "one_time_token": Token to authenticate an unsecure channel
             "local_code": Used to reauthorize if local_secret was set
        """
        method = 'authorize_user'
        params = {'username': username}
        machine_manager = self._server._machine_manager
        light_state = "chamber_ack" if chamber_blink else "acknowledge"
        def lcd_callback(response):
            machine_manager.pop_light_state(light_state)
            answer = response.get('result', {}).get('answer')
            if answer == 'accepted':
                result = self._do_authorize(
                    username, makerbot_token, local_secret, client)
                callback(result=result)
                return
            elif answer == 'rejected':
                error = {'code': 25, 'message': 'authorization rejected'}
            elif answer == 'timedout':
                error = {'code': 26, 'message': 'authorization timed out'}
            else:
                self._log.error('Unexpected response %r', response)
                # Produces extra log spam but sends an appropriate error
                error = {}
            callback(error=error)

        machine_manager.push_light_state(light_state)
        self._server.make_client_request('lcd', method, params, lcd_callback)

    def _query_token_ok(self, username, makerbot_token):
        ok = [False]
        bad = [False]
        no_connection = [False]
        def done():
            return ok[0] or bad[0] or no_connection[0]
        def success_cb(response):
            jr = json.loads(response)
            if jr.get('name', '').lower() == username.lower():
                ok[0] = True
            else:
                bad[0] = True
        def fail_cb(**kwargs):
            if kwargs['response_code'] == 401:
                bad[0] = True
            else:
                self._log.error("Auth failure: {}".format(kwargs))
                no_connection[0]=True
        # Let's ask the cloud
        self._log.info("Querying server for username {}".format(username))
        self._server.http_request(self._server._config['kaiten']['thingiverse_api_url'],
                                  "/users/me",
                                  'GET',
                                  token=makerbot_token,
                                  success_callback=success_cb,
                                  error_callback=fail_cb,
                                  timeout=20)
        while not done():
            yield
        return (ok[0], bad[0], no_connection[0])

    @kaiten.decorator.jsonrpc
    @kaiten.decorator.lower_priv
    @kaiten.decorator.require_secure
    @kaiten.decorator.pass_client
    def reauthorize(self, username:str, makerbot_token:str=None,
                    local_secret:str=None, local_code:str=None,
                    client=None) -> dict:
        """
        Reauthorize a previously authorized account

        This will never ask for verification via the bot ui.

        For all clients with a connected makerbot account, just the
        account username and the account token should be used.  Other
        clients should provide the username, local_secret, and
        local_code used in a previous call to authorize().

        @param username: Makerbot account name, or other display name
        @param makerbot_token: Makerbot account token
        @param local_secret: Random string for accountless auth
        @param local_code: Random string for accountless auth
        @return dict:  Dict containing:
             "one_time_token": Token to authenticate an unsecure channel
        """
        def fail(): raise JsonRpcException(27, 'invalid credentials')
        def no_connection(): raise JsonRpcException(29, 'auth_server_unreachable')
        if Account.check_username(username) is None: fail()
        account = self.make_account(username)
        token_ok = (makerbot_token is not None and
                    makerbot_token in account.makerbot_tokens)
        if not token_ok and makerbot_token is not None\
           and self._server.is_online():
            # Let's try and ask the cloud if the token is good
            (ok, bad, no_connect)\
                = yield from self._query_token_ok(username, makerbot_token)
            if ok:
                token_ok = True
                account.makerbot_tokens = makerbot_token
            if bad:
                # We got a makerbot token and a username but they're not
                # right!
                fail()
            if no_connect:
                no_connection()
        local_ok = account.check_local_auth(local_secret, local_code)
        if not token_ok and not local_ok: fail()

        client.account = account
        self._server.authenticate(client)
        one_time_token = self._randstring()
        self._account_map[one_time_token] = account
        yield
        return {'one_time_token': one_time_token}

    @kaiten.decorator.jsonrpc
    @kaiten.decorator.raise_priv
    @kaiten.decorator.require_secure
    @kaiten.decorator.pass_client
    @kaiten.decorator.send_analytics
    def fcgi_reauthorize(self, local_secret:str, local_code:str,
                         client=None) -> dict:
        """
        Shitty hack to support the fcgi server

        Same as reauthorize, but only accepts local auth, and searches
        all usernames for a matching (secret, code) pair.

        @param local_secret: Random string for accountless auth
        @param local_code: Random string for accountless auth
        @return dict:  Dict containing:
             "one_time_token": Token to authenticate an unsecure channel
             "username": The username for the matching local auth
        """
        for account in Account.all_accounts():
            username = account.username
            try:
                result = yield from self.reauthorize(username, local_secret=local_secret,
                                                     local_code=local_code, client=client)
                result['username'] = username
                return result
            except JsonRpcException as e:
                if e.code != 27: raise
        raise JsonRpcException(27, 'invalid credentials')

    @kaiten.decorator.jsonrpc
    @kaiten.decorator.lower_priv
    @kaiten.decorator.require_secure
    @kaiten.decorator.require_tether
    @kaiten.decorator.pass_client
    @kaiten.decorator.send_analytics
    def wifi_fre_authorize(self, username:str, makerbot_token:str=None,
                           local_secret:str=None, client=None) -> dict:
        """
        Authorize an account for the first time.

        This will never ask for verification via the bot ui, but will
        fail unless the given client is connected via the wifi
        tether.

        For all clients with a connected makerbot account, just the
        account username and the account token should be used.  Other
        clients should provide a descriptive, non generic username
        and a randomly generated local_secret, and must also store
        the returned local_code in order to reauthorize.

        If accepted this will both authenticate the current client and
        return a single use token that can be used to authenticate a
        single additional client.

        @param username: Makerbot account name, or other display name
        @param makerbot_token: Makerbot account token
        @param local_secret: Random string for accountless auth
        @return dict:  Dict containing:
             "one_time_token": Token to authenticate an unsecure channel
             "local_code": Used to reauthorize if local_secret was set
        """
        yield
        return self._do_authorize(
            username, makerbot_token, local_secret, client)

    @kaiten.decorator.jsonrpc
    @kaiten.decorator.lower_priv
    @kaiten.decorator.pass_client
    @kaiten.decorator.send_analytics
    def authenticate(self, access_token:str, client=None):
        """
        Authenticate a client on an unsecure channel

        Requires a one_time_token returned from an authorization call
        on a secure channel.  If successful, the client calling this
        method will be authenticated to invoke any public API method
        and to access any makerbot account tied to the authorization
        call that provided the one_time_token.

        @param access_token: Single use token from authorization call
        """
        if access_token in self._account_map:
            client.account = self._account_map.pop(access_token)
            self._server.authenticate(client)
        elif kaiten.constants.mock:
            # TODO: All clients should auth during tests
            client.account = self.make_account('mock')
            self._server.authenticate(client)
        else:
            self._log.info("Rejected authentication for connection")
            # TODO: Can we change the error without breaking conveyor?
            raise kaiten.error.AuthenticationException

    @kaiten.decorator.jsonrpc
    @kaiten.decorator.require_secure
    @kaiten.decorator.send_analytics
    def add_makerbot_account(self, username:str, makerbot_token:str):
        """
        Authorize a new makerbot account

        This method allows an already authorized client on a secure
        channel to authorize a new makerbot account.  The account
        used to authorize the invoking client is unaffected by the
        call and need have no relation to the new account.

        @param username: Makerbot account name
        @param makerbot_token: Makerbot account token
        """
        account = self.make_account(username)
        account.makerbot_tokens = makerbot_token
        
    @kaiten.decorator.jsonrpc
    @kaiten.decorator.require_secure
    @kaiten.decorator.send_analytics
    def add_local_auth(self, username:str, local_secret:str) -> str:
        """
        Add a new local authorization account

        This method allows an already authorized client on a secure
        channel to add a local authorization account.  The username may
        also refer to an existing account, in which case an additional
        local authorization code will be added to the account.  The
        account used to authorize the invoking client is unaffected by
        the call and need have no relation to the new account.

        @param username: Display name for the account
        @param local_secret: Random string for local auth
        @return str: local_code to authorize the new account
        """
        account = self.make_account(username)
        local_code = self._randstring()
        account.add_local_auth(local_secret, local_code)
        return local_code

    @kaiten.decorator.jsonrpc
    def get_authorized(self) -> list:
        """
        Return a list of authorized "accounts"

        Returns a list of dicts, with each dict describing an authorized
        "account".  Every account will have a unique "username" field, and
        will have a boolean "makerbot_account" field which tells us if
        there is at least one actual authorized makerbot account backing
        this local  account.  There will also be an integer "local_auth_count"
        field listing the number of local-only authentication tokens associated
        with the account.

        @return list: List of authorized "account" dicts.
        """
        result = []
        for account in Account.all_accounts():
            result.append({
                "username": account.username,
                "makerbot_account": len(account.makerbot_tokens) != 0,
                "local_auth_count": account.local_auth_count(),
            })
        return result

    @kaiten.decorator.jsonrpc
    @kaiten.decorator.pass_client
    def deauthorize(self, username:str, client=None):
        """
        Deauthorize the account with the given username

        This will deauthorize all makerbot accounts and all local-only
        authentication tokens associated with the given account.

        @param username: Username associated with a known account.
        """
        username = Account.check_username(username)
        if username is not None:
            Account.drop_username(username)
            for token in list(self._account_map):
                if self._account_map[token].username == username:
                    del self._account_map[token]
            self._server.drop_network_clients(
                username=username, client_to_keep=client)

    @kaiten.decorator.jsonrpc
    @kaiten.decorator.pass_client
    @kaiten.decorator.send_analytics
    def clear_authorized(self, client=None):
        """
        Clears all accounts authorized to this bot.

        Thingiverse tokens and client auth tokens are cleared, and we
        disconnect all authorized network clients, except for the client
        invoking this method.
        """
        Account.drop_all()
        self._account_map.clear()
        self._server.drop_network_clients(client_to_keep=client)
        if "first_registered_user" in self._server._config["kaiten"]:
            self._server.update_home_config({"first_registered_user":None})

    def make_account(self, username):
        """
        Return an account object with the given username.

        Note that if there is no known account with this username, this
        will be an account with no know authentication tokens, which is
        not usually what we want for use outside of this class.
        """
        return Account(username)

    def set_account(self, client, username):
        """
        Set a client's account to a given makerbot account

        This only verifies that we have an existing account that matches
        the username, and does not also verify that the caller has any
        account credentials, so some care should be taken with this.
        """
        if Account.check_username(username) is None:
            raise Exception('Bad account')
        account = self.make_account(username)
        client.account = account

    def get_makerbot_token_map(self):
        """ Return a mapping of makerbot_tokens to usernames """
        result = {}
        for account in Account.all_accounts():
            for t in account.makerbot_tokens:
                result[t] = account.username
        return result

    def _randstring(self, codelen=32):
        return ''.join(self._sysrand.choice(string.ascii_letters)
                       for x in range(codelen))

    def get_first_registered(self):
        """ Gets the username of the first authorized user on this machine
        """
        return self._server._config['kaiten'].get('first_registered_user', None)

    def _save_first_registered(self, username):
        """ Save the username of a user as the first authorized user.
        Can later be retrived with get_first_authorized
        """
        self._server.update_home_config({"first_registered_user":username})

    def _do_authorize(self, username, makerbot_token, local_secret, client):
        if (len(self.get_authorized()) == 0):
            self._save_first_registered(username)
        account = self.make_account(username)
        if makerbot_token:
            account.makerbot_tokens = makerbot_token
        one_time_token = self._randstring()
        self._account_map[one_time_token] = account
        result = {'one_time_token': one_time_token}
        if local_secret is not None:
            local_code = self._randstring()
            account.add_local_auth(local_secret, local_code)
            result['local_code'] = local_code
        client.account = account
        self._server.authenticate(client)
        return result
